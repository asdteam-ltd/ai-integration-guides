## 1. Вступ і для чого призначено

Ця методичка призначена для команд, які доопрацьовують проєкти, частково або повністю згенеровані штучним інтелектом. Вона встановлює правила стабільної інтеграції змін без перегляду архітектури, з фокусом на безпеку, контроль та швидкість доставки. Застосовується до проєктів, де важлива швидкість реалізації і високі вимоги до надійності.

---

## 2. Правила розробки

Цей розділ визначає базові вимоги до роботи з проєктами, які були повністю або частково згенеровані за допомогою штучного інтелекту. Його мета — забезпечити стабільність, передбачуваність та відповідність стандартам без внесення необґрунтованих змін до архітектури проєкту.


### 1. Заборона зміни архітектури

- Заборонено змінювати основну структуру проєкту без узгодження з техлідом або архітектором.
- Усі нові функціональні частини повинні інтегруватися в наявні модулі або реалізовуватися у вигляді ізольованих компонентів (сервіси, класи, пакети).

### 2. Дотримання стилю та шаблонів

- Використовуються лише наявні шаблони сервісів, контролерів, DTO, ентіті.
- Дотримання naming convention, структури пакетів і стилю форматування згідно з командними правилами.
- Заборонено створювати дублікати типів, моделей або сервісів без потреби.

### 3. Мінімізація зовнішніх залежностей

- Заборонено додавати сторонні бібліотеки без погодження (pull request має містити обґрунтування).
- Не використовувати залежності, які дублюють уже наявний функціонал.
- Уникати використання експериментальних або нестабільних пакетів (особливо тих, що рекомендовані LLM без перевірки).

### 4. Обовʼязкове логування критичних точок

- Усі критичні події повинні логуватись (вхід/вихід користувача, зміна прав доступу, платіжні транзакції, помилки).
- Заборонено логувати паролі, токени, платіжну або персональну інформацію.
- Логи мають бути структурованими та відповідати вимогам GDPR/конфіденційності.

### 5. Покриття змін тестами

- Уся нова логіка має бути покрита юніт-тестами.
- Складні сценарії — додатково покривати інтеграційними тестами.
- Мануальне тестування повинне бути описане або задокументоване, якщо автоматизоване недоступне.

### 6. Безпека коду

- Заборонено зберігати секрети (ключі, токени, паролі) у відкритому коді або конфігураціях.
- Усі API та службові ендпоінти мають бути захищені механізмами авторизації.
- Перевірка прав доступу повинна бути на рівні кожного запиту, а не лише на рівні UI.

---


## 3. Мануальні перевірки

### 1. Аутентифікація та авторизація

- Перевірити коректність реалізації логіки входу, реєстрації, відновлення пароля.
- Переконатися, що токени перевіряються належним чином (підпис, термін дії, структура).
- Перевірити, що права доступу розмежовані відповідно до ролей (наприклад: USER, ADMIN).
- Переконатися, що ендпоінти не доступні без авторизації або через маніпуляцію ID.

### 2. Критичні бізнес-процеси

- Перевірити поведінку системи при виконанні ключових дій: транзакцій, змін статусу, операцій із профілем, бронюванням.
- Пройти всі основні сценарії з обробкою подій, які можуть вплинути на дані або доступ.

### 3. Обробка чутливої інформації

- Переконатися, що персональні та фінансові дані не виводяться у відкритих API-відповідях, логах або UI.
- Перевірити відсутність токенів, паролів, адрес електронної пошти третіх осіб у браузерних інструментах розробника.
- Заборонено логувати секретні дані в консоль або бекенд-логи.

### 4. Поведінка при помилках та нестандартних ситуаціях

- Перевірити реакцію системи на прострочені або невалідні токени.
- Оцінити поведінку системи при відсутніх або частково заповнених даних.
- Спробувати викликати 4xx/5xx помилки й перевірити обробку на клієнті та сервері.

### 5. Високоризикові функції UI

- Перевірити наявність підтвердження дій (modal, CAPTCHA, 2FA) для критичних операцій: видалення, зміни статусів, оновлення фінансових даних.
- Переконатися, що дії не можуть бути виконані випадково або повторно без контролю.

### 6. Адміністративна частина

- Перевірити, що доступ до адміністративних інтерфейсів обмежений лише користувачами з відповідними правами.
- Оцінити доступність функцій через API та UI — критичні функції не повинні бути досяжні через підстановку ID або рольових обхідних маніпуляцій.

---

## 4. Автоматизовані перевірки

Автоматизовані перевірки забезпечують базовий рівень безпеки, якості та стабільності у проєктах, створених або доповнених за допомогою AI. Їх запуск є обов’язковим перед інтеграцією змін до основної гілки або релізом функціоналу.

### 1. Статичний аналіз коду (SAST)

- Запускається автоматично при коміті або в CI-пайплайні.
- Використовується SonarQube або інші аналоги.
- Виявляє вразливості, антипатерни, мертві ділянки коду, небезпечну логіку.
- Обов’язково усувати всі помилки рівня *critical* і *high* перед мержем.

### 2. Аналіз залежностей (Dependency Scanning)

- Виконується перевірка сторонніх бібліотек на відомі вразливості.
- Основний інструмент — OWASP Dependency Check або аналог.
- У разі наявності критичних проблем — мерж блокується, доки залежність не оновлено або не зафіксовано виключення.

### 3. Динамічний аналіз (DAST)

- Проводиться в тестовому середовищі (dev/stage) з використанням OWASP ZAP або Burp Suite.
- Перевіряються публічні API, сценарії логіну, транзакції, взаємодія з UI.
- Має запускатись щонайменше перед кожним релізом.

### 4. Перевірка секретів і токенів

- Обов’язково перевіряти репозиторій на витік секретів за допомогою Trufflehog, Git-secrets або GitGuardian.
- Наявність токена або ключа в історії комітів повинна розглядатись як інцидент безпеки.

### 5. AI-аудит коду

- Використовується Claude.ai або інші LLM для додаткової перевірки критичних частин проєкту.
- Проводиться точково або на всій кодовій базі перед основним релізом.
- Генерується звіт із коментарями, ризиками та пропозиціями покращення.

### 6. Інтеграція в CI/CD

- Усі автоматизовані перевірки мають бути частиною CI/CD пайплайну.
- Результати перевірок відображаються у Pull Request або окремому дашборді.
- Критичні помилки блокують мерж до їх усунення або обґрунтованого винятку.

---

## 5. Тестування і моніторинг

Тестування та моніторинг відіграють ключову роль у забезпеченні надійності, передбачуваності та стабільності проєктів, що створені або доповнені з використанням штучного інтелекту. Через підвищену ймовірність помилок у AI-згенерованому коді, тестування має бути системним і багаторівневим.

### 1. Юніт- та інтеграційне тестування

- Уся бізнес-логіка повинна бути покрита юніт-тестами.
- Для API, що взаємодіють із базою або сторонніми сервісами, обов’язкове інтеграційне тестування.
- Тести мають бути частиною CI-пайплайну та запускатись при кожному коміті.

### 2. Перевірка критичних сценаріїв вручну

- Важливі процеси (авторизація, платежі, оновлення прав, бронювання) мають бути перевірені вручну, навіть за наявності автоматизованих тестів.
- Результати ручного тестування повинні бути зафіксовані у вигляді чекліста або коментаря до Pull Request.

### 3. Поведінкове тестування AI-коду

- Особливу увагу приділяти нестандартній поведінці: неоднозначним умовам, рандомізації, автоматично створеним шаблонам.
- У разі сумнівів у логіці — проводити ревʼю декількома розробниками.

### 4. Тестування на середовищах (staging/dev)

- Перед релізом зміни мають бути розгорнуті на окремому середовищі.
- Усі критичні сценарії проходять smoke-тестування (перевірка ключової функціональності).
- Дані для тестування не повинні містити реальних персональних або фінансових даних.

### 5. Пост-релізний моніторинг

- Після релізу у production вмикається посилений моніторинг:
   - логи помилок,
   - трекінг подій (аналітика),
   - алерти за ключовими метриками (CPU, memory, errors, delays).
- У випадку аномалій — оперативно вмикається rollback або hotfix.

### 6. Автоматизоване сповіщення та логування

- Всі серйозні винятки повинні логуватись і дублюватися у системі сповіщень (наприклад, Slack, PagerDuty).
- Використовувати централізовані сервіси логування (наприклад, ELK, Datadog, Sentry).

---

## 6. Вразливі місця

AI-згенерований код часто містить приховані ризики — як у бізнес-логіці, так і в інфраструктурі. Цей розділ узагальнює найтиповіші вразливі зони, які вимагають підвищеної уваги під час ревʼю, тестування та аудиту.

> Цей список рекомендовано винести у внутрішню базу знань або методичку з кейсами/антипатернами, що регулярно оновлюється.

### 1. Аутентифікація та авторизація

- Відсутність перевірки підпису токена або його терміну дії.
- Необмежений доступ до ресурсів незалежно від ролі.
- Обхід авторизації через зміну ідентифікаторів (ID-based access control).
- Відсутність 2FA/OTP або необов’язковість MFA для чутливих дій.

### 2. Обробка введених даних

- Відсутня серверна валідація (тільки клієнтська перевірка).
- Використання даних без sanitation/escaping → XSS.
- SQL/NoSQL інʼєкції через динамічне формування запитів.
- Масові оновлення/видалення без обмеження обсягу або контексту.

### 3. Збереження та передача чутливої інформації

- Зберігання паролів, токенів, ключів у відкритому коді, .env або логах.
- Відсутність шифрування або неправильна реалізація TLS.
- Відсутність control policy (CORS, CSP), що дозволяє витік даних через інші домени.

### 4. Зовнішні інтеграції та API

- API викликаються без rate limiting, retry-policy, авторизації.
- Використання AI-згенерованих запитів без перевірки структури та відповідей.
- Передача даних без підпису або автентифікації.

### 5. Інфраструктура та DevOps

- Публічні середовища без обмеження доступу (стейджинг у відкритому доступі).
- Відсутність ізоляції середовищ (prod, staging, dev працюють на одній базі).
- Застарілі або неперевірені залежності, які автоматично зʼявилися в AI-згенерованому коді.

### 6. Логування та моніторинг

- Відсутність логування важливих дій (логін, помилки, транзакції).
- Логування конфіденційної інформації (паролі, токени, фінансові дані).
- Відсутність моніторингу спроб зловмисної активності або змін ролей.

### 7. Надійність AI-згенерованого коду

- Випадки, коли AI створює код без перевірки виключень, null-перевірок, обробки країв.
- Потенційно шкідливі залежності, які виглядають «легітимно».
- Невиправдано складна або нелогічна бізнес-логіка, яка не проходила ревʼю.
- Вбудовані бекдори (наприклад, прихований адмін-доступ або hardcoded bypass).

### 8. Атаки на рівні API

- Відсутність обмежень (throttling, rate limiting) — відкритість до DoS.
- Ненадійна обробка асинхронних подій (webhooks, queues).
- Відсутність контролю розміру/типу запитів.

---

## 7. AI сканнінг і джоба

Автоматизований AI-сканінг допомагає виявляти потенційні вразливості, проблеми стилю, складність логіки та інші ризики, характерні для AI-згенерованого коду. Цей підхід доповнює класичні перевірки (SAST/DAST) і дозволяє підвищити якість коду без суттєвого навантаження на команду ревʼю.

> 📌 Мета: вбудувати аналіз AI у CI/CD пайплайн і зробити його доступним для будь-якого проєкту в команді.

> Результат AI-аналізу не повинен замінювати код-ревʼю, але може допомогти швидше виявити нетипові чи критичні проблеми, особливо в AI-згенерованому або legacy-коді.

#### Вимоги до реалізації

- **Безпечна передача коду** — не передавати приватні частини проєкту або дані, що підлягають NDA.
- **Обмеження обсягу** — передавати лише релевантні ділянки (без ресурсів, тестів, legacy).
- **Конфігурація фільтрів** — задавати список виключень, наприклад: `build/`, `node_modules/`, `*.test.*`.

### 1. **Вхідні параметри:**

- URL або шлях до Git-репозиторію.
- Конкретна гілка, файл або директорія для аналізу.

### 2. **Попередні перевірки:**

- Запуск базових сканерів (SAST, DAST, Dependency Check, Secret Scan).
- Формування попереднього звіту з технічних інструментів.

### 3. **AI-аналіз:**

- Передача окремих модулів/файлів або звітів у LLM (наприклад, Claude.ai).
- Аналіз коду з точки зору:
   - відповідності стилю,
   - вразливостей,
   - відсутності перевірок або тестів,
   - дублювання,
   - нелогічної або надлишкової логіки.

### 4. **Формування результатів:**

- Зведений звіт у форматі Markdown або JSON.
- Оцінка ризиків, коментарі, пропозиції змін.

### 5. **Інтеграція в процеси:**

- Додавання результатів у Pull Request як коментар або артефакт.
- Блокування мержу при наявності критичних AI-виявлень (опційно).
- Надсилання результатів у Slack, email або через dashboard.
