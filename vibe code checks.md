## 1. Вступ: Мета та область застосування

Ця методичка призначена для команд, які доопрацьовують проєкти, частково або повністю згенеровані штучним інтелектом. Вона встановлює базові правила, що дозволяють швидко інтегрувати зміни без перегляду архітектури, з фокусом на безпеку та стабільність. Методичка застосовується до проєктів, де час реалізації є критичним, а стабільність і безпечність - пріоритетними.


## 2. Правила розробки

Щоб інтеграція нових функцій у AI-згенерований проєкт була стабільною і контрольованою, дотримуйтесь таких принципів:

1. **Не змінювати архітектуру**
   – Не рефакторити основну структуру без затвердження.
   – Новий код додається в існуючі модулі або як ізольовані сервіси/компоненти.

2. **Дотримуватись стилю та шаблонів**
   – Використовувати наявні сервіси, DTO, ентіті, контролери.
   – Дотримуватись naming-convention, структури пакетів і форматування коду.

3. **Мінімізувати залежності**
   – Не додавати нові бібліотеки без письмового узгодження.
   – Уникати дублювання коду, сервісів, моделей.

4. **Обов’язкове логування ключових точок**
   – Дії типу логін, зміна ролі, помилки, транзакції - мають логуватись.
   – Не логувати персональні або платіжні дані.

5. **Тестування змін**
   – Обов’язково покривати нову логіку unit-тестами.
   – Важливі шляхи (автентифікація, зміна статусу, API помилок) - перевірити вручну.

6. **Безпека передусім**
   – Не зберігати токени, паролі або ключі в коді чи логах.
   – Усі API мають бути захищені авторизацією.


## 3. Вимоги до безпеки

Для проєктів, що згенеровані або доопрацьовані за участі AI, безпека є критичним елементом. Перед релізом кожної фічі обов’язкове виконання наступного:

1. **Статичний аналіз коду (SAST)**
   – Використовувати SonarQube або аналогічний інструмент.
   – Виправити всі критичні та високі вразливості.

2. **Динамічне тестування (DAST)**
   – Сканування через OWASP ZAP або Burp Suite.
   – Особлива увага до ендпоінтів авторизації та платіжних операцій.

3. **Перевірка секретів і токенів**
   – Аналіз репозиторію за допомогою `git-secrets`, `trufflehog`.
   – Заборонено зберігати секрети у відкритому коді або `.env` без шифрування.

4. **Ручна перевірка критичних компонентів**
   – Логін, реєстрація, відновлення паролю.
   – Доступ до адміністративних функцій.
   – Обробка платіжних та персональних даних.

5. **Фінальна перевірка через Claude.ai**
   – Генерація короткого аудиту із виявленими ризиками та порадами щодо усунення.


## 4. Ідентифікація критичних точок

AI-згенеровані проєкти часто містять слабкі місця у критичних зонах. Їх необхідно перевіряти в першу чергу, незалежно від загального обсягу змін:

1. **Аутентифікація та авторизація**

* Ненадійна логіка аутентифікації
* Відсутність перевірки прав доступу
* Неправильне управління сесіями та токенами
* Порушення принципу найменших привілеїв

2. **Обробка введених даних**

* Відсутність або слабка валідація введення
* Обхід валідаційної логіки
* Вразливість до SQL/NoSQL-інʼєкцій
* Вразливість до XSS

3. **Збереження та передача чутливої інформації**

* Збереження паролів, токенів, секретів у відкритому вигляді
* Відсутність HTTPS / неправильна реалізація TLS
* Порушення політик CORS та CSP

4. **Зовнішні інтеграції та API**

* Неконтрольований доступ до зовнішніх API
* API з фінансовими транзакціями без обмежень
* Використання AI-згенерованих запитів без перевірки

5. **Інфраструктура та DevOps**

* Відсутність сек’юріті-сканінгу в CI/CD
* Публічне розгортання без ізоляції середовищ
* Вразливості через застарілі або невідомі залежності

6. **Логування та моніторинг**

* Відсутність логування важливих подій
* Витік чутливих даних через логи
* Слабкий моніторинг аномалій та спроб атак

7. **Надійність AI-згенерованого коду**

* Вбудовані бекдори
* Некоректна логіка або обробка виключень
* Відсутність ревʼю з боку розробників

8. **Перевантаження API**

* DoS через необмежені запити
* Відсутність rate limiting / throttling
* Ненадійна обробка асинхронних подій

Перевірка цих зон має бути пріоритетною незалежно від того, генерувався код AI чи редагувався вручну.


## 5. Типові помилки

AI-генерований код часто виглядає правильним, але має серйозні вразливості. Нижче наведено найпоширеніші помилки, які зустрічаються в реальних проєктах:
Ось нейтрально сформульований розділ **«Типові помилки та кейси з практики»**, без прив'язки до конкретних мов чи інструментів:

1. Небезпечна обробка токенів

* Відсутність перевірки підпису та терміну дії токенів.
* Недостатній контроль ролей або прав доступу.
* Використання ненадійних алгоритмів або слабких ключів для підпису.

2. Ін’єкції та необроблене введення параметрів

* Формування запитів до бази даних або інших систем без належної перевірки.
* Можливість виконання стороннього коду або небажаних команд.
* Відсутність параметризації та валідації.

3. Вразливості пов’язані з відображенням даних

* Виведення введеної інформації без екранування або фільтрації.
* Можливість впровадження шкідливого вмісту у відображуваний інтерфейс.

4. Неналежне поводження з конфіденційною інформацією

* Жорстке кодування паролів, ключів доступу чи конфігурацій.
* Недостатній контроль за тим, які дані потрапляють у публічні репозиторії.
* Відсутність шифрування або обмеження доступу до критичних даних.

5. Недостатня перевірка доступу

* Можливість виконання дій без авторизації.
* Відкриті або неправильно захищені API чи функції.

6. Поверхнева валідація даних

* Тільки клієнтська валідація, без серверної
* Відсутність перевірки структури, формату або меж значень.

7. Специфічні ризики при використанні AI

* Підміна логіки через маніпуляцію промптами (prompt injection).
* Рекомендації небезпечних або неіснуючих залежностей.
* Можливе ненавмисне збереження чи передача конфіденційних даних AI-моделлю.


## 6. Security Scanning

Для забезпечення базового рівня безпеки у проектах, що генеруються або допрацьовуються за участі ШІ, необхідно пройти мінімальний набір перевірок. Рекомендується дотримуватись наступної послідовності:

1. **Статичний аналіз коду (SAST)**
   Запустити перевірку коду за допомогою SonarQube або аналогічного інструменту для виявлення вразливостей, антипатернів і небезпечної логіки.

2. **Аналіз залежностей**
   Виконати перевірку сторонніх бібліотек і залежностей на наявність відомих вразливостей через OWASP Dependency Check або подібні сканери.

3. **Динамічний аналіз застосунку (DAST)**
   Провести сканування активного застосунку (інтерфейси, API) через OWASP ZAP або Burp Suite, зосереджуючись на ключових точках (автентифікація, обробка даних, транзакції).

4. **Перевірка конфіденційних даних у репозиторії**
   Запустити інструменти для пошуку секретів у коді, такі як Git-secrets або Trufflehog. Уникати зберігання ключів, токенів та паролів у відкритому вигляді.

5. **Ручний аудит критичних сценаріїв**
   Перевірити вручну логіку аутентифікації, реєстрації, фінансових операцій, а також дії, що вимагають підвищених прав доступу.

6. **Аналіз через локальний AI аналізатор коду**
   Завантажити код проєкту або його частини в локальний аналізатор з метою отримання структурованого звіту про потенційні ризики та пропозиції з покращення безпеки.


## 7. Перспективи автоматизації процесів

З метою підвищення стабільності та швидкості перевірок, доцільно автоматизувати етапи аналізу безпеки та якості коду в рамках CI/CD-процесів. Це дозволяє виявляти критичні проблеми ще до ручного ревʼю та зменшує залежність від людського фактору.


CI/CD-джоба має виконувати повний цикл аналізу коду з наступною логікою:

1. **Вхідний параметр — URL або git-репозиторій**
   Джоба отримує шлях до репозиторію, ініціює клонування або підключення.

2. **Статичний аналіз (SAST)**
   Автоматичний запуск перевірки на вразливості у вихідному коді (SonarQube або інші).
   Вивантаження результатів з оцінкою ризиків по кожному файлу/модулю.

3. **Перевірка залежностей**
   Аналіз використовуваних бібліотек через OWASP Dependency Check або аналог, виявлення вразливих версій.

4. **Динамічний аналіз (DAST)**
   Автоматичне деплоювання проєкту в тестове середовище та запуск перевірки через OWASP ZAP або Burp Suite.

5. **Пошук секретів у коді**
   Сканування за допомогою Trufflehog, GitGuardian, git-secrets на наявність токенів, паролів, API-ключів.

6. **Інтеграція з AI для аудиту**
   Обрані частини коду або результат сканувань надсилаються в Claude.ai чи інші LLM для додаткової оцінки та генерації рекомендацій щодо покращення безпеки й архітектури.

7. **Формування звіту**
   Збір усіх результатів перевірок у зведений звіт з:\n
   – критичністю проблем,\n
   – можливими шляхами виправлення,\n
   – посиланнями на конкретні місця в коді,\n
   – статусом проходження перевірок.

8. **Інтеграція у процеси команди**
   Результати доступні у вигляді коментарів до Pull Request або на дашборді команди.
   Можливість відмови від мержу у випадку критичних проблем.

